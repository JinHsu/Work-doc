## 索引

### MySQL常用存储引擎

InnoDB、MyISAM、Memory



### 索引数据结构：B+树

- B+树非叶子节点没有数据域，能够存储更多的索引数据，降低树的高度

- B+树的叶子节点有指向下一个相邻叶子节点的指针，在查找一片连续的数据时，可以很快的返回数据。

> InnoDB也支持HASH索引结构，但默认为BTREE

### 聚集索引和非聚集索引

聚集索引的叶子节点的数据域就是数据（行数据）本身（InnoBD）；

非聚集索引的叶子节点的数据域是主键（InnoBD）或者文件地址（MyISAM）

### 回表

需要查询不在的非聚集索引（也叫二级索引）字段中的一些字段，这时候就需要通过非聚集索引数据域的主键去聚簇索引中查找这些字段。这种查找就叫做回表。

> 回表只出现在InnoDB存储引擎中。

### 覆盖索引

在进行查询的时候，查询的字段已经包含在某个索引的列中了，这种查询不需要回表操作，这样的索引的叫做覆盖索引。

### 索引下推

索引下推具体是在复合索引的查询中，针对特定的过滤条件而进行减少回表次数而做的优化。降低了IO

> explain的extra字段结果时Using where，表示优化器需要通过索引回表查询数据。
>
> explain的extra字段是Using index condition，表示会先通过条件过滤索引，再通过过滤后的索引查询符合索引条件的数据。



### 索引创建规则

1. 表的主键、外键必须有索引；
2. 数据量超过300的表应该有索引；
3. 经常与其他表进行连接的表，在连接字段上应该建立索引；
4. 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5. 索引应该建在选择性高的字段上；
6. 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7. 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
    - 正确选择复合索引中的主列字段，一般是选择性较好的字段；
    - 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
    - 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
    - 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
    - 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
8. 频繁进行数据操作的表，不要建立太多的索引；
9. 删除无用的索引，**避免对执行计划造成负面影响**； 以上是一些普遍的建立索引时的判断依据。一言以蔽之，索引的建立必须慎重，对每个索引的必要性都应该经过仔细分析，要有建立的依据。因为太多的索引与不充分、不正确的索引对性能都毫无益处：在表上建立的每个索引都会**增加存储开销**，索引对于插入、删除、更新操作也会**增加处理上的开销**。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据**增加删除时的性能**，特别是对频繁更新的表来说，负面影响更大



## 事务

ACID：

- 原子性（Atomicity）

    一次事务中的所有操作，要么全部成功，要么全部失败。

- 一致性（Consistency）

    转账：A账户给B账户转账200元，A账户-200，那么B账户+200，结果A+B账户的金额总和不会变。

- 隔离性（Isolation）

    事务之间通过锁的机制实现隔离，彼此之间不可见。

- 持久性（Durability）

    数据库发生故障，也能够保证数据会持久到数据库中。

### 事务隔离级别

事务的隔离级别是通过锁的机制来实现的。MySQL默认的隔离级别是可重复度，Oracle为读已提交。

- 读未提交

    读到其他事务未提交的数据，产生脏读。

- 读已提交

     解决了脏读的问题。但会出现不可重复度的问题。就是在事务提交前后读到的数据不一样。

- 可重复读

     解决了不可重复度的问题，即在事务提交了前后读到的数据都是一样的，但会出现幻读。如提交前根据name查询为'张三'的数据只有1条，但是在提交的过程中，又插入了一条name为'张三'的数据，最终会得到2条数据

- 序列化

    最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行

```sql
show variables like '%tx_isolation%';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.01 sec)
```

## 锁

锁是事务性数据库中为了保证数据一致性的一种手段。

InnoDB的锁：表锁、行锁；行锁又分为：读锁（共享锁）、写锁（排它锁）

行锁，根据数据锁定范围又分为：

- 记录锁

    锁定一条记录

- 间隙锁（Gap Locks，又称区间锁）

    锁定一个范围。

- Next-key Lock

    锁定一个范围，并包含记录本身。可以解决幻读的问题。

> MVCC：全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。

死锁：2个或2个以上的事务相互持有和请求锁，并形成一个循环依赖关系，就会产生死锁。InnoDB会自动检测事务死锁，立即回滚其中的某个事务，并且返回一个错误。

当死锁频繁发生，就要注意检查代码了。**调整SQL的操作顺序或者缩短事务的长度**。粗化锁的粒度。



## 优化

### 慢SQL优化

- 慢查询的开启并捕获。
- explain+慢SQL分析。
- show profile查询SQL在MySQL服务器里的执行细节和生命周期。
- MySQL数据库服务器的参数调优。

#### 1.慢查询开启

```sql
show variables like '%slow_query_log%';
set global slow_query_log = 1;--当前数据库生效
--永久生效需要需改配置文件
show variables like 'long_query_time%';--默认慢查询的时间（大于）
set global long_query_time = 3;
show global status like 'Slow_queries%';--显示慢SQL的条数
```

#### 2.explain分析

```sql
explain select * from rbac_user;
```

<img src="/Users/jinhsu/Github/sharit-projects/sharit-blog/docs/.images/db-005.png" />

- id

    id相同，执行顺序由上至下；id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

- Select_type

    主要有：`SIMPLE`，`PRIMARY`，`SUBQUERY`，`DERIVED`，`UNION`，`UNION RESULT`

- table

- type

    访问类型：`system` > `const` > `eq_ref` > `ref` > `range` > `index` > `ALL`

- possible_keys  

- key

- Key_len

- ref

- rows

- Extra

#### 3.show profile

```sql
show variables like 'profiling';
set profiling=on;
show profiles;
show profile cpu, block io for query 4;
```

#### 4.服务器参数调优



### 索引优化

- 索引失效

1. 字段值精确匹配
2. 最佳左前缀法则（查询从索引的最左列开始并且不能跳过索引的中间的列）；
3. 不要在索引列上做任何操作（计算、函数、类型转换）；
4. 存储引擎不能使用索引中范围条件右边的列；
5. 尽量使用覆盖索引（只访问索引列的查询，也就是索引列和查询列一致，不用`select *`）
6. 不要使用不等于(`!=`或则`<>`)逻辑判断;
7. 不要使用`IS NULL`或者`IS NOT NULL`;
8. 不要使用`like`以通配符(`'%abc_'`)开头，通配符只能在右边，创建覆盖索引(遵循第4条)以避免
9. 字符串不加单引号；索引列进行了类型转换（违背第2条）
10. 少用`OR`

查询条件字段添加（联合）索引，**范围查询**字段不要建立索引（范围查询字段会导致索引失效）;

左连接，给右表的连接字段添加索引；

右连接，给左表的连接字段添加索引；

禁止大表JOIN

合理利用覆盖索引



## 主从复制



## 集群模式